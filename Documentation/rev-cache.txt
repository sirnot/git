rev-cache porcelain
===================

A front end for the rev-cache API is provided with the builtin utility 
`rev-cache`.  It is mainly intended for cache slice generation and maintenance, 
but can also walk commits within a slice.  At the moment it is not particularly 
advanced, but is sufficient for repository administration.

It's general syntax is:

`git-rev-cache COMMAND [options] [<commit-id>...]`

With the commands:

`add`::
	Add revisions to the cache.  Reads commit ids from stdin, formatted as:
	`END END ... \--not START START ...`
+
Options:

`\--all`:: Include all heads as ends.
`\--fresh`:: Exclude everything already in a cache slice.
`\--stdin`:: Also read commit ids from stdin (seperated by newline, `\--not` 
also valid).
`\--legs`:: Ensure branch has no "dangling" starts (ie. is self-contained).
`\--noobjects`:: Don't include non-commit objects.

`walk`::
	Walk a cache slice based on set of commits; formatted as add.
+
Options:

`\--objects`:: Include non-commit objects in traversal.

`fuse`::
	Coagulate several cache slices into a single large slice.
+
Options:

`\--all`:: Include all objects in repository.  Will only traverse as of cache 
ends if this is not specified.
`\--noobjects`:: Don't include non-commit objects.
`\--ignore-size[=N]`:: Do not fuse slices of file size >= `N`.  If `N` is not 
given the cutoff size defaults to ~5MB.

`index`::
	Regenerate the cache index.


For an explanation of the API and its inner workings, see 
link:technical/rev-cache.txt[technical info on rev-cache]
